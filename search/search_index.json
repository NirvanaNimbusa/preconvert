{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Preconvert A Library to enable preconversion of any Python type into one that is easily serializable. Preconvert provides a way to define conversions from more complex objects and datastructures into the base types before serialization happens. This happens in a way that is independant of the eventual form of serialization, allowing you to easily then serialize into multiple formats. Why? Have you ever tried to json.dumps a data structure, only to be surprised when your DataClass throws an exception, or your namedtuple outputs as a list? Preconvert was created to solve this problem across common serialization formats. Before Preconvert: import sys import json from dataclasses import dataclass @dataclass class InventoryItem: \"\"\"Class for keeping track of an item in inventory.\"\"\" name: str unit_price: float quantity_on_hand: int = 0 def total_cost(self) -> float: return self.unit_price * self.quantity_on_hand my_store_inventory = [InventoryItem(\"beer\", unit_price=0.0, quantity_on_hand=sys.maxsize), InventoryItem(\"bacon\", unit_price=2.5, quantity_on_hand=3)] json.dumps(my_store_inventory) output >>> 177 178 --> 179 raise TypeError(f'Object of type {o.__class__.__name__} ' 180 f'is not JSON serializable') 181 TypeError: Object of type InventoryItem is not JSON serializable D: After preconvert: import sys import json from preconvert.output import json @dataclass class InventoryItem: \"\"\"Class for keeping track of an item in inventory.\"\"\" name: str unit_price: float quantity_on_hand: int = 0 def total_cost(self) -> float: return self.unit_price * self.quantity_on_hand my_store_inventory = [InventoryItem(\"beer\", unit_price=0.0, quantity_on_hand=sys.maxsize), InventoryItem(\"bacon\", unit_price=2.5, quantity_on_hand=3)] json.dumps(my_store_inventory) >>> '[{\"name\": \"beer\", \"unit_price\": 0.0, \"quantity_on_hand\": 9223372036854775807}, {\"name\": \"bacon\", \"unit_price\": 2.5, \"quantity_on_hand\": 3}]' :D Design goals: Enable conversion from complex to simple types independant of desired output format Provide built in conversion for common types that are not universally supported (dataclasses, namedtuple, etc...) Provide a way to build custom preconverts or override built-in preconverts Ability to build preconverts that are dependent on the destination format Easy utilization from existing projects Minimal overhead when utilized with common serialization formats How do I use this? Download pip3 install preconvert Utilize If your project uses one of our built-in supported serializers (json, msgpak, bson) you can simply replace your existing serializer import with a preconvert one: from preconvert.outputs import json OR from preconvert.outputs import simplejson as json OR from preconvert.outputs import msgpack OR from preconvert.outputs import bson If not you can inject preconvert before usage of any other serializers, often by setting a default or on_onknown parameter: import preconvert import my_serializer my_serializer.dumps(default=preconvert.default_serializable) How do I extend this? Want to add preconversion to your own custom types? For OOP projects, one easy way to do this is to add a __jsonifiable__ method to your object: class MyCustomClass(object): def __init__(self, first_name, children=()): self.first_name = first_name self.children = children def __jsonifiable__(self) return {'first': self.first_name, 'children': children} For other entities, such as objects you do not control, you can register a new preconvert using the preconvert.converter decorator: import preconvert @preconvert.converter(SomeFrameworkObject) def convert_framework_object(instance): return {'name': instance.name} You can also, optionally, specify preconversions per an intended serialization format: import preconvert @preconvert.json(SomeFrameworkObject) def convert_framework_object(instance): return {'json': {'name': instance.name}} @preconvert.msgpack(SomeFrameworkObject) def convert_framework_object(instance): return ['name', instance.name]","title":"Home"},{"location":"#preconvert","text":"A Library to enable preconversion of any Python type into one that is easily serializable. Preconvert provides a way to define conversions from more complex objects and datastructures into the base types before serialization happens. This happens in a way that is independant of the eventual form of serialization, allowing you to easily then serialize into multiple formats.","title":"Preconvert"},{"location":"#why","text":"Have you ever tried to json.dumps a data structure, only to be surprised when your DataClass throws an exception, or your namedtuple outputs as a list? Preconvert was created to solve this problem across common serialization formats. Before Preconvert: import sys import json from dataclasses import dataclass @dataclass class InventoryItem: \"\"\"Class for keeping track of an item in inventory.\"\"\" name: str unit_price: float quantity_on_hand: int = 0 def total_cost(self) -> float: return self.unit_price * self.quantity_on_hand my_store_inventory = [InventoryItem(\"beer\", unit_price=0.0, quantity_on_hand=sys.maxsize), InventoryItem(\"bacon\", unit_price=2.5, quantity_on_hand=3)] json.dumps(my_store_inventory) output >>> 177 178 --> 179 raise TypeError(f'Object of type {o.__class__.__name__} ' 180 f'is not JSON serializable') 181 TypeError: Object of type InventoryItem is not JSON serializable D: After preconvert: import sys import json from preconvert.output import json @dataclass class InventoryItem: \"\"\"Class for keeping track of an item in inventory.\"\"\" name: str unit_price: float quantity_on_hand: int = 0 def total_cost(self) -> float: return self.unit_price * self.quantity_on_hand my_store_inventory = [InventoryItem(\"beer\", unit_price=0.0, quantity_on_hand=sys.maxsize), InventoryItem(\"bacon\", unit_price=2.5, quantity_on_hand=3)] json.dumps(my_store_inventory) >>> '[{\"name\": \"beer\", \"unit_price\": 0.0, \"quantity_on_hand\": 9223372036854775807}, {\"name\": \"bacon\", \"unit_price\": 2.5, \"quantity_on_hand\": 3}]' :D","title":"Why?"},{"location":"#design-goals","text":"Enable conversion from complex to simple types independant of desired output format Provide built in conversion for common types that are not universally supported (dataclasses, namedtuple, etc...) Provide a way to build custom preconverts or override built-in preconverts Ability to build preconverts that are dependent on the destination format Easy utilization from existing projects Minimal overhead when utilized with common serialization formats","title":"Design goals:"},{"location":"#how-do-i-use-this","text":"Download pip3 install preconvert Utilize If your project uses one of our built-in supported serializers (json, msgpak, bson) you can simply replace your existing serializer import with a preconvert one: from preconvert.outputs import json OR from preconvert.outputs import simplejson as json OR from preconvert.outputs import msgpack OR from preconvert.outputs import bson If not you can inject preconvert before usage of any other serializers, often by setting a default or on_onknown parameter: import preconvert import my_serializer my_serializer.dumps(default=preconvert.default_serializable)","title":"How do I use this?"},{"location":"#how-do-i-extend-this","text":"Want to add preconversion to your own custom types? For OOP projects, one easy way to do this is to add a __jsonifiable__ method to your object: class MyCustomClass(object): def __init__(self, first_name, children=()): self.first_name = first_name self.children = children def __jsonifiable__(self) return {'first': self.first_name, 'children': children} For other entities, such as objects you do not control, you can register a new preconvert using the preconvert.converter decorator: import preconvert @preconvert.converter(SomeFrameworkObject) def convert_framework_object(instance): return {'name': instance.name} You can also, optionally, specify preconversions per an intended serialization format: import preconvert @preconvert.json(SomeFrameworkObject) def convert_framework_object(instance): return {'json': {'name': instance.name}} @preconvert.msgpack(SomeFrameworkObject) def convert_framework_object(instance): return ['name', instance.name]","title":"How do I extend this?"},{"location":"__auto__/preconvert.bson/","text":"","title":"Preconvert.bson"},{"location":"__auto__/preconvert.convert/","text":"Module preconvert.convert Functions default_serializer(item, namespace='base', base_namespace='base', using=<PreconversionSource.ALL_PACKAGES: 1>, store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7fcbf0bb7730>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7fcbf0bb77b8>, <class 'datetime.date'>: <function datetime_converter at 0x7fcbf0bb7840>, <class 'datetime.datetime'>: <function datetime_converter at 0x7fcbf0bb7840>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7fcbf0bb78c8>, <enum 'Enum'>: <function use_value_attribute at 0x7fcbf0bb7950>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7fcbf0bb79d8>}}}) : Classes PreconversionSource(*args, **kwargs) : All globally available conversion sources ### Ancestors (in MRO) * enum.Enum ### Class variables `ALL_PACKAGES` : `PRECONVERT` :","title":"Preconvert.convert"},{"location":"__auto__/preconvert.convert/#module-preconvertconvert","text":"","title":"Module preconvert.convert"},{"location":"__auto__/preconvert.convert/#functions","text":"default_serializer(item, namespace='base', base_namespace='base', using=<PreconversionSource.ALL_PACKAGES: 1>, store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7fcbf0bb7730>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7fcbf0bb77b8>, <class 'datetime.date'>: <function datetime_converter at 0x7fcbf0bb7840>, <class 'datetime.datetime'>: <function datetime_converter at 0x7fcbf0bb7840>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7fcbf0bb78c8>, <enum 'Enum'>: <function use_value_attribute at 0x7fcbf0bb7950>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7fcbf0bb79d8>}}}) :","title":"Functions"},{"location":"__auto__/preconvert.convert/#classes","text":"PreconversionSource(*args, **kwargs) : All globally available conversion sources ### Ancestors (in MRO) * enum.Enum ### Class variables `ALL_PACKAGES` : `PRECONVERT` :","title":"Classes"},{"location":"__auto__/preconvert.converters/","text":"Module preconvert.converters Functions byte_converter(item) : convert_data_class(instance) : convert_namedtuple(instance) : Converts a tuple of type namedtuple to a dict. This isn't registered as injecting this via registration won't work because it will never be falling through to as tuples convert to list. if the tuple isn't a named one, it will return the tuple unchanged datetime_converter(item) : time_delta_converter(item) : use_value_attribute(item) :","title":"Preconvert.converters"},{"location":"__auto__/preconvert.converters/#module-preconvertconverters","text":"","title":"Module preconvert.converters"},{"location":"__auto__/preconvert.converters/#functions","text":"byte_converter(item) : convert_data_class(instance) : convert_namedtuple(instance) : Converts a tuple of type namedtuple to a dict. This isn't registered as injecting this via registration won't work because it will never be falling through to as tuples convert to list. if the tuple isn't a named one, it will return the tuple unchanged datetime_converter(item) : time_delta_converter(item) : use_value_attribute(item) :","title":"Functions"},{"location":"__auto__/preconvert.exceptions/","text":"Module preconvert.exceptions Defines all exceptions that can be thrown by the preconvert project Classes Error(*args, **kwargs) : Base class for exceptions thrown from the preconvert project ### Ancestors (in MRO) * builtins.Exception * builtins.BaseException ### Descendants * preconvert.exceptions.ExistingConverter * preconvert.exceptions.Unconvertable ExistingConverter(kind, existing, new) : Should be raised when a converter already exists for a specified type ### Ancestors (in MRO) * preconvert.exceptions.Error * builtins.Exception * builtins.BaseException Unconvertable(item) : Raised when the provided item is not convertable using the provided converter(s) ### Ancestors (in MRO) * preconvert.exceptions.Error * builtins.Exception * builtins.BaseException","title":"Preconvert.exceptions"},{"location":"__auto__/preconvert.exceptions/#module-preconvertexceptions","text":"Defines all exceptions that can be thrown by the preconvert project","title":"Module preconvert.exceptions"},{"location":"__auto__/preconvert.exceptions/#classes","text":"Error(*args, **kwargs) : Base class for exceptions thrown from the preconvert project ### Ancestors (in MRO) * builtins.Exception * builtins.BaseException ### Descendants * preconvert.exceptions.ExistingConverter * preconvert.exceptions.Unconvertable ExistingConverter(kind, existing, new) : Should be raised when a converter already exists for a specified type ### Ancestors (in MRO) * preconvert.exceptions.Error * builtins.Exception * builtins.BaseException Unconvertable(item) : Raised when the provided item is not convertable using the provided converter(s) ### Ancestors (in MRO) * preconvert.exceptions.Error * builtins.Exception * builtins.BaseException","title":"Classes"},{"location":"__auto__/preconvert.json/","text":"","title":"Preconvert.json"},{"location":"__auto__/preconvert/","text":"Module preconvert A Library to enable preconversion of any Python type into one that is easily serializable Sub-modules preconvert.convert preconvert.converters preconvert.exceptions preconvert.output preconvert.register Functions converter(*kinds, scope='base', store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7f5af22d56a8>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7f5af22d5730>, <class 'datetime.date'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.datetime'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7f5af22d5840>, <enum 'Enum'>: <function use_value_attribute at 0x7f5af22d58c8>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7f5af22d5950>}}}, override=False, package=<AutoPackage.FUNCTION_OR_PRECONVERT: 3>) : A decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged. default_serializer(item, namespace='base', base_namespace='base', using=<PreconversionSource.ALL_PACKAGES: 1>, store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7f5af22d56a8>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7f5af22d5730>, <class 'datetime.date'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.datetime'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7f5af22d5840>, <enum 'Enum'>: <function use_value_attribute at 0x7f5af22d58c8>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7f5af22d5950>}}}) :","title":"Preconvert"},{"location":"__auto__/preconvert/#module-preconvert","text":"A Library to enable preconversion of any Python type into one that is easily serializable","title":"Module preconvert"},{"location":"__auto__/preconvert/#sub-modules","text":"preconvert.convert preconvert.converters preconvert.exceptions preconvert.output preconvert.register","title":"Sub-modules"},{"location":"__auto__/preconvert/#functions","text":"converter(*kinds, scope='base', store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7f5af22d56a8>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7f5af22d5730>, <class 'datetime.date'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.datetime'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7f5af22d5840>, <enum 'Enum'>: <function use_value_attribute at 0x7f5af22d58c8>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7f5af22d5950>}}}, override=False, package=<AutoPackage.FUNCTION_OR_PRECONVERT: 3>) : A decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged. default_serializer(item, namespace='base', base_namespace='base', using=<PreconversionSource.ALL_PACKAGES: 1>, store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7f5af22d56a8>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7f5af22d5730>, <class 'datetime.date'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.datetime'>: <function datetime_converter at 0x7f5af22d57b8>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7f5af22d5840>, <enum 'Enum'>: <function use_value_attribute at 0x7f5af22d58c8>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7f5af22d5950>}}}) :","title":"Functions"},{"location":"__auto__/preconvert.msgpack/","text":"","title":"Preconvert.msgpack"},{"location":"__auto__/preconvert.output/","text":"Module preconvert.output Exposes all output formatters that have built-in support for preconversion Note: the interesting try: catch: pattern is done as their isn't a guarantee that the user has any of the given output formatters installed, which is required for preconvert to plug-in it's preconversion. Sub-modules preconvert.output.bson preconvert.output.json preconvert.output.msgpack preconvert.output.simplejson","title":"Preconvert.output"},{"location":"__auto__/preconvert.output/#module-preconvertoutput","text":"Exposes all output formatters that have built-in support for preconversion Note: the interesting try: catch: pattern is done as their isn't a guarantee that the user has any of the given output formatters installed, which is required for preconvert to plug-in it's preconversion.","title":"Module preconvert.output"},{"location":"__auto__/preconvert.output/#sub-modules","text":"preconvert.output.bson preconvert.output.json preconvert.output.msgpack preconvert.output.simplejson","title":"Sub-modules"},{"location":"__auto__/preconvert.preconvert.converters/","text":"Module preconvert.converters Functions byte_converter(item) : convert_data_class(instance) : convert_namedtuple(instance) : Converts a tuple of type namedtuple to a dict. This isn't registered as injecting this via registration won't work because it will never be falling through to as tuples convert to list. if the tuple isn't a named one, it will return the tuple unchanged datetime_converter(item) : time_delta_converter(item) : use_value_attribute(item) :","title":"Preconvert.preconvert.converters"},{"location":"__auto__/preconvert.preconvert.converters/#module-preconvertconverters","text":"","title":"Module preconvert.converters"},{"location":"__auto__/preconvert.preconvert.converters/#functions","text":"byte_converter(item) : convert_data_class(instance) : convert_namedtuple(instance) : Converts a tuple of type namedtuple to a dict. This isn't registered as injecting this via registration won't work because it will never be falling through to as tuples convert to list. if the tuple isn't a named one, it will return the tuple unchanged datetime_converter(item) : time_delta_converter(item) : use_value_attribute(item) :","title":"Functions"},{"location":"__auto__/preconvert.register/","text":"Module preconvert.register This module handles the registration of preconverters Functions converter(*kinds, scope='base', store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7f74fe400730>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7f74fe4007b8>, <class 'datetime.date'>: <function datetime_converter at 0x7f74fe400840>, <class 'datetime.datetime'>: <function datetime_converter at 0x7f74fe400840>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7f74fe4008c8>, <enum 'Enum'>: <function use_value_attribute at 0x7f74fe400950>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7f74fe4009d8>}}}, override=False, package=<AutoPackage.FUNCTION_OR_PRECONVERT: 3>) : A decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged. Classes AutoPackage(*args, **kwargs) : Provides options for the automatic determination of a package name ### Ancestors (in MRO) * enum.Enum ### Class variables `FUNCTION` : `FUNCTION_OR_PRECONVERT` : `PRECONVERT` :","title":"Preconvert.register"},{"location":"__auto__/preconvert.register/#module-preconvertregister","text":"This module handles the registration of preconverters","title":"Module preconvert.register"},{"location":"__auto__/preconvert.register/#functions","text":"converter(*kinds, scope='base', store={'preconvert': {'base': {<class 'object'>: <function convert_data_class at 0x7f74fe400730>, typing.Collection: <class 'list'>, <class 'generator'>: <class 'tuple'>, typing.Mapping: <class 'dict'>, <class 'decimal.Decimal'>: <class 'str'>, <class 'uuid.UUID'>: <class 'str'>, <class 'bytes'>: <function byte_converter at 0x7f74fe4007b8>, <class 'datetime.date'>: <function datetime_converter at 0x7f74fe400840>, <class 'datetime.datetime'>: <function datetime_converter at 0x7f74fe400840>, <class 'datetime.timedelta'>: <function time_delta_converter at 0x7f74fe4008c8>, <enum 'Enum'>: <function use_value_attribute at 0x7f74fe400950>, <class 'typing.NamedTuple'>: <function convert_namedtuple at 0x7f74fe4009d8>}}}, override=False, package=<AutoPackage.FUNCTION_OR_PRECONVERT: 3>) : A decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged.","title":"Functions"},{"location":"__auto__/preconvert.register/#classes","text":"AutoPackage(*args, **kwargs) : Provides options for the automatic determination of a package name ### Ancestors (in MRO) * enum.Enum ### Class variables `FUNCTION` : `FUNCTION_OR_PRECONVERT` : `PRECONVERT` :","title":"Classes"},{"location":"__auto__/preconvert.simplejson/","text":"","title":"Preconvert.simplejson"}]}