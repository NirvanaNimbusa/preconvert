{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"preconvert Supercharge your serialization! Preconvert is a library that extends existing serializiers (json, simplejson, bson, msgpack, ..) to be capable of converting the types you use. It accomplishes this by efficiently preconverting just the types the serializers aren't aware of (things like dataclasses and namedtuples) into basic built-in types that all serializers can understand. It then provides a mechanism for you to build custom preconverters, and preconvert_plugins that automatically take effect when installed via pip. Why? Have you ever tried to json.dumps a data structure, only to be surprised when your DataClass throws an exception, or your namedtuple outputs as a list? Preconvert was created to solve this problem across common serialization formats. Before Preconvert: import sys import json from dataclasses import dataclass @dataclass class InventoryItem : \"\"\"Class for keeping track of an item in inventory.\"\"\" name : str unit_price : float quantity_on_hand : int = 0 def total_cost ( self ) -> float : return self . unit_price * self . quantity_on_hand my_store_inventory = [ InventoryItem ( \"beer\" , unit_price = 0.0 , quantity_on_hand = sys . maxsize ), InventoryItem ( \"bacon\" , unit_price = 2.5 , quantity_on_hand = 3 )] json . dumps ( my_store_inventory ) output >>> 177 178 --> 179 raise TypeError ( f 'Object of type {o.__class__.__name__} ' 180 f 'is not JSON serializable' ) 181 TypeError : Object of type InventoryItem is not JSON serializable D : After preconvert: import sys import json from preconvert.output import json @dataclass class InventoryItem : \"\"\"Class for keeping track of an item in inventory.\"\"\" name : str unit_price : float quantity_on_hand : int = 0 def total_cost ( self ) -> float : return self . unit_price * self . quantity_on_hand my_store_inventory = [ InventoryItem ( \"beer\" , unit_price = 0.0 , quantity_on_hand = sys . maxsize ), InventoryItem ( \"bacon\" , unit_price = 2.5 , quantity_on_hand = 3 )] json . dumps ( my_store_inventory ) >>> '[{\"name\": \"beer\", \"unit_price\": 0.0, \"quantity_on_hand\": 9223372036854775807}, {\"name\": \"bacon\", \"unit_price\": 2.5, \"quantity_on_hand\": 3}]' : D Design goals: Enable conversion from complex to simple types independant of desired output format Provide built in conversion for common types that are not universally supported (dataclasses, namedtuple, etc...) Provide a way to build custom preconverts or override built-in preconverts Ability to build preconverts that are dependent on the destination format Easy utilization from existing projects Minimal overhead when utilized with common serialization formats How do I use this? Download pip3 install preconvert Utilize If your project uses one of our built-in supported serializers (json, msgpak, bson) you can simply replace your existing serializer import with a preconvert one: from preconvert.outputs import json OR from preconvert.outputs import simplejson as json OR from preconvert.outputs import msgpack OR from preconvert.outputs import bson If not you can inject preconvert before usage of any other serializers, often by setting a default or on_onknown parameter: import preconvert import my_serializer my_serializer . dumps ( default = preconvert . default_serializable ) How do I extend this? Want to add preconversion to your own custom types? For OOP projects, one easy way to do this is to add a __jsonifiable__ method to your object: class MyCustomClass ( object ): def __init__ ( self , first_name , children = ()): self . first_name = first_name self . children = children def __jsonifiable__ ( self ) return { 'first' : self . first_name , 'children' : children } For other entities, such as objects you do not control, you can register a new preconvert using the preconvert.converter decorator: import preconvert @preconvert.converter ( SomeFrameworkObject ) def convert_framework_object ( instance ): return { 'name' : instance . name } You can also, optionally, specify preconversions per an intended serialization format: import preconvert @preconvert.json ( SomeFrameworkObject ) def convert_framework_object ( instance ): return { 'json' : { 'name' : instance . name }} @preconvert.msgpack ( SomeFrameworkObject ) def convert_framework_object ( instance ): return [ 'name' , instance . name ]","title":"Home"},{"location":"#preconvert","text":"Supercharge your serialization! Preconvert is a library that extends existing serializiers (json, simplejson, bson, msgpack, ..) to be capable of converting the types you use. It accomplishes this by efficiently preconverting just the types the serializers aren't aware of (things like dataclasses and namedtuples) into basic built-in types that all serializers can understand. It then provides a mechanism for you to build custom preconverters, and preconvert_plugins that automatically take effect when installed via pip.","title":"preconvert"},{"location":"#why","text":"Have you ever tried to json.dumps a data structure, only to be surprised when your DataClass throws an exception, or your namedtuple outputs as a list? Preconvert was created to solve this problem across common serialization formats. Before Preconvert: import sys import json from dataclasses import dataclass @dataclass class InventoryItem : \"\"\"Class for keeping track of an item in inventory.\"\"\" name : str unit_price : float quantity_on_hand : int = 0 def total_cost ( self ) -> float : return self . unit_price * self . quantity_on_hand my_store_inventory = [ InventoryItem ( \"beer\" , unit_price = 0.0 , quantity_on_hand = sys . maxsize ), InventoryItem ( \"bacon\" , unit_price = 2.5 , quantity_on_hand = 3 )] json . dumps ( my_store_inventory ) output >>> 177 178 --> 179 raise TypeError ( f 'Object of type {o.__class__.__name__} ' 180 f 'is not JSON serializable' ) 181 TypeError : Object of type InventoryItem is not JSON serializable D : After preconvert: import sys import json from preconvert.output import json @dataclass class InventoryItem : \"\"\"Class for keeping track of an item in inventory.\"\"\" name : str unit_price : float quantity_on_hand : int = 0 def total_cost ( self ) -> float : return self . unit_price * self . quantity_on_hand my_store_inventory = [ InventoryItem ( \"beer\" , unit_price = 0.0 , quantity_on_hand = sys . maxsize ), InventoryItem ( \"bacon\" , unit_price = 2.5 , quantity_on_hand = 3 )] json . dumps ( my_store_inventory ) >>> '[{\"name\": \"beer\", \"unit_price\": 0.0, \"quantity_on_hand\": 9223372036854775807}, {\"name\": \"bacon\", \"unit_price\": 2.5, \"quantity_on_hand\": 3}]' : D","title":"Why?"},{"location":"#design-goals","text":"Enable conversion from complex to simple types independant of desired output format Provide built in conversion for common types that are not universally supported (dataclasses, namedtuple, etc...) Provide a way to build custom preconverts or override built-in preconverts Ability to build preconverts that are dependent on the destination format Easy utilization from existing projects Minimal overhead when utilized with common serialization formats","title":"Design goals:"},{"location":"#how-do-i-use-this","text":"Download pip3 install preconvert Utilize If your project uses one of our built-in supported serializers (json, msgpak, bson) you can simply replace your existing serializer import with a preconvert one: from preconvert.outputs import json OR from preconvert.outputs import simplejson as json OR from preconvert.outputs import msgpack OR from preconvert.outputs import bson If not you can inject preconvert before usage of any other serializers, often by setting a default or on_onknown parameter: import preconvert import my_serializer my_serializer . dumps ( default = preconvert . default_serializable )","title":"How do I use this?"},{"location":"#how-do-i-extend-this","text":"Want to add preconversion to your own custom types? For OOP projects, one easy way to do this is to add a __jsonifiable__ method to your object: class MyCustomClass ( object ): def __init__ ( self , first_name , children = ()): self . first_name = first_name self . children = children def __jsonifiable__ ( self ) return { 'first' : self . first_name , 'children' : children } For other entities, such as objects you do not control, you can register a new preconvert using the preconvert.converter decorator: import preconvert @preconvert.converter ( SomeFrameworkObject ) def convert_framework_object ( instance ): return { 'name' : instance . name } You can also, optionally, specify preconversions per an intended serialization format: import preconvert @preconvert.json ( SomeFrameworkObject ) def convert_framework_object ( instance ): return { 'json' : { 'name' : instance . name }} @preconvert.msgpack ( SomeFrameworkObject ) def convert_framework_object ( instance ): return [ 'name' , instance . name ]","title":"How do I extend this?"},{"location":"CONTRIBUTING/","text":"Contributing to preconvert Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting preconvert set up for local development The first step when contributing to any project is getting it set up on your local machine. preconvert aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.5+ pipenv bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/preconvert.git `cd preconvert pipenv sync Install preconvert itself with pip install . or pip install -e . (for editable mode). Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main preconvert project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the ACKNOWLEDGEMENTS.md list :). Thank you! I can not tell you how thankful I am for the hard work done by preconvert contributors like you . Thank you! ~Timothy Crosley","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-preconvert","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to preconvert"},{"location":"CONTRIBUTING/#getting-preconvert-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. preconvert aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.5+ pipenv bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/preconvert.git `cd preconvert pipenv sync Install preconvert itself with pip install . or pip install -e . (for editable mode).","title":"Getting preconvert set up for local development"},{"location":"CONTRIBUTING/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main preconvert project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the ACKNOWLEDGEMENTS.md list :).","title":"Making a contribution"},{"location":"CONTRIBUTING/#thank-you","text":"I can not tell you how thankful I am for the hard work done by preconvert contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"preconvert/","text":"Module preconvert A Library to enable preconversion of any Python type into one that is easily serializable Sub-modules preconvert.convert preconvert.converters preconvert.exceptions preconvert.output preconvert.register Functions converter def ( * kinds : Any , scope : str = 'base' , store : Dict [ str , Dict [ str , Dict [ str , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}}, override : bool = False , package : Union [ str , preconvert . register . AutoPackage ] = < AutoPackage . FUNCTION_OR_PRECONVERT : 3 > ) -> Callable decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged. default_serializer def ( item : Any , namespace : str = 'base' , base_namespace : str = 'base' , using : Union [ Iterable [ str ], preconvert . convert . PreconversionSource ] = < PreconversionSource . ALL_PACKAGES : 1 > , store : Dict [ str , Dict [ str , Dict [ Any , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}} )","title":"Preconvert"},{"location":"preconvert/#module-preconvert","text":"A Library to enable preconversion of any Python type into one that is easily serializable","title":"Module preconvert"},{"location":"preconvert/#sub-modules","text":"preconvert.convert preconvert.converters preconvert.exceptions preconvert.output preconvert.register","title":"Sub-modules"},{"location":"preconvert/#functions","text":"","title":"Functions"},{"location":"preconvert/#converter","text":"def ( * kinds : Any , scope : str = 'base' , store : Dict [ str , Dict [ str , Dict [ str , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}}, override : bool = False , package : Union [ str , preconvert . register . AutoPackage ] = < AutoPackage . FUNCTION_OR_PRECONVERT : 3 > ) -> Callable decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged.","title":"converter"},{"location":"preconvert/#default_serializer","text":"def ( item : Any , namespace : str = 'base' , base_namespace : str = 'base' , using : Union [ Iterable [ str ], preconvert . convert . PreconversionSource ] = < PreconversionSource . ALL_PACKAGES : 1 > , store : Dict [ str , Dict [ str , Dict [ Any , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}} )","title":"default_serializer"},{"location":"preconvert/convert/","text":"Module preconvert.convert Functions default_serializer def ( item : Any , namespace : str = 'base' , base_namespace : str = 'base' , using : Union [ Iterable [ str ], preconvert . convert . PreconversionSource ] = < PreconversionSource . ALL_PACKAGES : 1 > , store : Dict [ str , Dict [ str , Dict [ Any , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}} ) Classes PreconversionSource class ( * args , ** kwargs ) : All globally available conversion sources ### Ancestors ( in MRO ) * enum . Enum ### Class variables ``` python3 ALL_PACKAGES ``` : ``` python3 PRECONVERT ``` :","title":"Convert"},{"location":"preconvert/convert/#module-preconvertconvert","text":"","title":"Module preconvert.convert"},{"location":"preconvert/convert/#functions","text":"","title":"Functions"},{"location":"preconvert/convert/#default_serializer","text":"def ( item : Any , namespace : str = 'base' , base_namespace : str = 'base' , using : Union [ Iterable [ str ], preconvert . convert . PreconversionSource ] = < PreconversionSource . ALL_PACKAGES : 1 > , store : Dict [ str , Dict [ str , Dict [ Any , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}} )","title":"default_serializer"},{"location":"preconvert/convert/#classes","text":"","title":"Classes"},{"location":"preconvert/convert/#preconversionsource","text":"class ( * args , ** kwargs ) : All globally available conversion sources ### Ancestors ( in MRO ) * enum . Enum ### Class variables ``` python3 ALL_PACKAGES ``` : ``` python3 PRECONVERT ``` :","title":"PreconversionSource"},{"location":"preconvert/converters/","text":"Module preconvert.converters Functions byte_converter def ( item ) convert_data_class def ( instance ) convert_namedtuple def ( instance : Any ) -> Union [ Dict , tuple ] nverts a tuple of type namedtuple to a dict. This isn't registered as injecting this via registration won't work because it will never be falling through to as tuples convert to list. if the tuple isn't a named one, it will return the tuple unchanged datetime_converter def ( item ) time_delta_converter def ( item ) use_value_attribute def ( item )","title":"Converters"},{"location":"preconvert/converters/#module-preconvertconverters","text":"","title":"Module preconvert.converters"},{"location":"preconvert/converters/#functions","text":"","title":"Functions"},{"location":"preconvert/converters/#byte_converter","text":"def ( item )","title":"byte_converter"},{"location":"preconvert/converters/#convert_data_class","text":"def ( instance )","title":"convert_data_class"},{"location":"preconvert/converters/#convert_namedtuple","text":"def ( instance : Any ) -> Union [ Dict , tuple ] nverts a tuple of type namedtuple to a dict. This isn't registered as injecting this via registration won't work because it will never be falling through to as tuples convert to list. if the tuple isn't a named one, it will return the tuple unchanged","title":"convert_namedtuple"},{"location":"preconvert/converters/#datetime_converter","text":"def ( item )","title":"datetime_converter"},{"location":"preconvert/converters/#time_delta_converter","text":"def ( item )","title":"time_delta_converter"},{"location":"preconvert/converters/#use_value_attribute","text":"def ( item )","title":"use_value_attribute"},{"location":"preconvert/exceptions/","text":"Module preconvert.exceptions Defines all exceptions that can be thrown by the preconvert project Classes Error class ( * args , ** kwargs ) : Base class for exceptions thrown from the preconvert project ### Ancestors ( in MRO ) * builtins . Exception * builtins . BaseException ### Descendants * preconvert . exceptions . ExistingConverter * preconvert . exceptions . Unconvertable ExistingConverter class ( kind , existing , new ) : Should be raised when a converter already exists for a specified type ### Ancestors ( in MRO ) * preconvert . exceptions . Error * builtins . Exception * builtins . BaseException Unconvertable class ( item ) : Raised when the provided item is not convertable using the provided converter(s) ### Ancestors ( in MRO ) * preconvert . exceptions . Error * builtins . Exception * builtins . BaseException","title":"Exceptions"},{"location":"preconvert/exceptions/#module-preconvertexceptions","text":"Defines all exceptions that can be thrown by the preconvert project","title":"Module preconvert.exceptions"},{"location":"preconvert/exceptions/#classes","text":"","title":"Classes"},{"location":"preconvert/exceptions/#error","text":"class ( * args , ** kwargs ) : Base class for exceptions thrown from the preconvert project ### Ancestors ( in MRO ) * builtins . Exception * builtins . BaseException ### Descendants * preconvert . exceptions . ExistingConverter * preconvert . exceptions . Unconvertable","title":"Error"},{"location":"preconvert/exceptions/#existingconverter","text":"class ( kind , existing , new ) : Should be raised when a converter already exists for a specified type ### Ancestors ( in MRO ) * preconvert . exceptions . Error * builtins . Exception * builtins . BaseException","title":"ExistingConverter"},{"location":"preconvert/exceptions/#unconvertable","text":"class ( item ) : Raised when the provided item is not convertable using the provided converter(s) ### Ancestors ( in MRO ) * preconvert . exceptions . Error * builtins . Exception * builtins . BaseException","title":"Unconvertable"},{"location":"preconvert/register/","text":"Module preconvert.register This module handles the registration of preconverters Functions converter def ( * kinds : Any , scope : str = 'base' , store : Dict [ str , Dict [ str , Dict [ str , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}}, override : bool = False , package : Union [ str , preconvert . register . AutoPackage ] = < AutoPackage . FUNCTION_OR_PRECONVERT : 3 > ) -> Callable decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged. Classes AutoPackage class ( * args , ** kwargs ) : Provides options for the automatic determination of a package name ### Ancestors ( in MRO ) * enum . Enum ### Class variables ``` python3 FUNCTION ``` : ``` python3 FUNCTION_OR_PRECONVERT ``` : ``` python3 PRECONVERT ``` :","title":"Register"},{"location":"preconvert/register/#module-preconvertregister","text":"This module handles the registration of preconverters","title":"Module preconvert.register"},{"location":"preconvert/register/#functions","text":"","title":"Functions"},{"location":"preconvert/register/#converter","text":"def ( * kinds : Any , scope : str = 'base' , store : Dict [ str , Dict [ str , Dict [ str , Callable ]]] = { 'preconvert' : { 'base' : { < class ' object '>: <function convert_data_class at 0x7f25e9965400>, typing.Collection: <class ' list '>, <class ' generator '>: <class ' tuple '>, typing.Mapping: <class ' dict '>, <class ' decimal . Decimal '>: <class ' str '>, <class ' uuid . UUID '>: <class ' str '>, <class ' bytes '>: <function byte_converter at 0x7f25e9965488>, <class ' datetime . date '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . datetime '>: <function datetime_converter at 0x7f25e9965510>, <class ' datetime . timedelta '>: <function time_delta_converter at 0x7f25e9965598>, <enum ' Enum '>: <function use_value_attribute at 0x7f25e9965620>, <class ' typing . NamedTuple '>: <function convert_namedtuple at 0x7f25e99656a8>, <class ' numpy . ndarray '>: <function numpy_listable at 0x7f25d4815d90>, <class ' str '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . str_ '>: <function numpy_stringable at 0x7f25d44a8378>, <class ' numpy . bytes_ '>: <function numpy_byte_decodeable at 0x7f25d43d30d0>, <class ' numpy . bool_ '>: <function numpy_boolable at 0x7f25d43d3158>, <class ' numpy . integer '>: <function numpy_integerable at 0x7f25d43d31e0>, <class ' float '>: <function numpy_floatable at 0x7f25d43d3268>, <class ' numpy . floating '>: <function numpy_floatable at 0x7f25d43d3268>}}}, override : bool = False , package : Union [ str , preconvert . register . AutoPackage ] = < AutoPackage . FUNCTION_OR_PRECONVERT : 3 > ) -> Callable decorator that registers the wrapped function as a pre-converter for the provided types in the provided store data structure or a default global one. Returns the decorated function unchanged.","title":"converter"},{"location":"preconvert/register/#classes","text":"","title":"Classes"},{"location":"preconvert/register/#autopackage","text":"class ( * args , ** kwargs ) : Provides options for the automatic determination of a package name ### Ancestors ( in MRO ) * enum . Enum ### Class variables ``` python3 FUNCTION ``` : ``` python3 FUNCTION_OR_PRECONVERT ``` : ``` python3 PRECONVERT ``` :","title":"AutoPackage"},{"location":"preconvert/output/","text":"Module preconvert.output Exposes all output formatters that have built-in support for preconversion Note: the interesting try: catch: pattern is done as their isn't a guarantee that the user has any of the given output formatters installed, which is required for preconvert to plug-in it's preconversion. Sub-modules preconvert.output.bson preconvert.output.json preconvert.output.msgpack preconvert.output.simplejson","title":"Output"},{"location":"preconvert/output/#module-preconvertoutput","text":"Exposes all output formatters that have built-in support for preconversion Note: the interesting try: catch: pattern is done as their isn't a guarantee that the user has any of the given output formatters installed, which is required for preconvert to plug-in it's preconversion.","title":"Module preconvert.output"},{"location":"preconvert/output/#sub-modules","text":"preconvert.output.bson preconvert.output.json preconvert.output.msgpack preconvert.output.simplejson","title":"Sub-modules"},{"location":"preconvert/output/bson/","text":"Module preconvert.output.bson Functions dump def ( content , * args , on_unknown = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'bson' ), ** kwargs ) ON dump with preconversion for common unserializable types in place dumps def ( content , * args , on_unknown = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'bson' ), ** kwargs ) ON dumps with preconversion for common unserializable types in place","title":"BSON"},{"location":"preconvert/output/bson/#module-preconvertoutputbson","text":"","title":"Module preconvert.output.bson"},{"location":"preconvert/output/bson/#functions","text":"","title":"Functions"},{"location":"preconvert/output/bson/#dump","text":"def ( content , * args , on_unknown = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'bson' ), ** kwargs ) ON dump with preconversion for common unserializable types in place","title":"dump"},{"location":"preconvert/output/bson/#dumps","text":"def ( content , * args , on_unknown = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'bson' ), ** kwargs ) ON dumps with preconversion for common unserializable types in place","title":"dumps"},{"location":"preconvert/output/json/","text":"Module preconvert.output.json Functions dump def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'json' ), ** kwargs ) ON dump with preconversion for common unserializable types in place dumps def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'json' ), ** kwargs ) ON dumps with preconversion for common unserializable types in place","title":"JSON"},{"location":"preconvert/output/json/#module-preconvertoutputjson","text":"","title":"Module preconvert.output.json"},{"location":"preconvert/output/json/#functions","text":"","title":"Functions"},{"location":"preconvert/output/json/#dump","text":"def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'json' ), ** kwargs ) ON dump with preconversion for common unserializable types in place","title":"dump"},{"location":"preconvert/output/json/#dumps","text":"def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'json' ), ** kwargs ) ON dumps with preconversion for common unserializable types in place","title":"dumps"},{"location":"preconvert/output/msgpack/","text":"Module preconvert.output.msgpack Functions dump def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpack dump with preconversion for common unserializable types in place dumps def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpacks dump with preconversion for common unserializable types in place pack def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpacks with preconversion for common unserializable types in place packb def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpacks with preconversion for common unserializable types in place","title":"MsgPack"},{"location":"preconvert/output/msgpack/#module-preconvertoutputmsgpack","text":"","title":"Module preconvert.output.msgpack"},{"location":"preconvert/output/msgpack/#functions","text":"","title":"Functions"},{"location":"preconvert/output/msgpack/#dump","text":"def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpack dump with preconversion for common unserializable types in place","title":"dump"},{"location":"preconvert/output/msgpack/#dumps","text":"def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpacks dump with preconversion for common unserializable types in place","title":"dumps"},{"location":"preconvert/output/msgpack/#pack","text":"def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpacks with preconversion for common unserializable types in place","title":"pack"},{"location":"preconvert/output/msgpack/#packb","text":"def ( content , * args , default = functools . partial ( < function default_serializer at 0x7f25e99e5ae8 > , namespace = 'msgpack' ), ** kwargs ) gpacks with preconversion for common unserializable types in place","title":"packb"},{"location":"preconvert/output/simplejson/","text":"Module preconvert.output.simplejson","title":"SimpleJSON"},{"location":"preconvert/output/simplejson/#module-preconvertoutputsimplejson","text":"","title":"Module preconvert.output.simplejson"}]}